include c.snip

# #include <...>
snippet inc
options     head
alias   #inc, #include
    #include <${1:TARGET}>

# #include "..."
snippet inc2
options     head
alias   #inc2, #include2
    #include "${1:TARGET}"

snippet     template
abbr        template <T>
    template<typename ${1:T}> ${0}

snippet     class
options     head
abbr        class {}
    class ${1:#:name} {
        ${2}
    public:
        $1(${3});
    };
    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class-without-constructor
options     head
abbr        class {}
    class ${1:#:name} {
        ${2}
    };

snippet     try
options     head
abbr        try catch
    try {
        ${1:#:TARGET}
    } catch (${2:...}) {
        ${3}
    }

# range based for ( C++11 feature )
snippet     for_in
options     head
abbr        for (:) {}
alias forin
    for (auto&& ${1:var} : ${2:#:container}) {
        ${0:TARGET}
    }

# lambda expression ( C++11 feature )
snippet     lambda
abbr        [](){}
    [${1}](${2})${3}{ ${4:TARGET} }${0:;}

snippet     static_cast
abbr        static_cast<>()
    static_cast<${1}>(${2})${0}

snippet     reinterpret_cast
abbr        reinterpret_cast<>()
    reinterpret_cast<${1}>(${2})${0}

snippet     const_cast
abbr        const_cast<>()
    const_cast<${1}>(${2})${0}

snippet     dynamic_cast
abbr        dynamic_cast<>()
    dynamic_cast<${1}>(${2})${0}

snippet     helloworld
abbr        #include<iostream> int main...
    #include <iostream>

    int main(int argc, char const* argv[])
    {
        std::cout << "hello, world!" << std::endl;
        return 0;
    }

snippet string
alias str
  std::string ${0:s};

snippet vector
alias vec
  std::vector<${1}> ${2:v};

snippet vector_string
alias vecs
  std::vector<std::string> ${2:vs};

snippet vector_int
alias veci
  std::vector<int> ${2:vi};

snippet     cout
options     head
abbr cout << var << endl;
  std::cout << ${0:TARGET} << std::endl;

snippet newline
abbr cout << endl;
alias nl
  std::cout << std::endl;

snippet cin
abbr cin >> var;
  std::cin >> ${0:TARGET};

snippet reverse
abbr reverse(start_iterator, end_iterator)
alias rev
  std::reverse(${1}.begin(), $1.end());

snippet rotate
abbr rotate(start_iterator, pivot_iterator, end_iterator)
alias rot
  std::rotate(${1}.begin(), $1.begin()+${3}, $1.end());

snippet pair
abbr pair<T, U> p
  std::pair<${1}, ${2}> ${3:p};

snippet map
abbr map<T, U> m
  std::map<${1}, ${2}> ${3:m};

snippet unordered_map
abbr unordered_map<T, U> m
alias umap
  std::unordered_map<${1}, ${2}> ${3:m};

snippet set
abbr set<T> s;
  std::set<${1}> ${2:s};

snippet unordered_set
abbr unordered_set<T> s
alias uset
  std::unordered_set<${1}> ${2:s};

snippet long long
alias ll
  long long ${0:TARGET}

snippet stringstream
abbr std::stringstream
alias ss
  std:stringstream ${0:ss};

snippet competitive_main
alias cp_main
  /*
   *  _________________________________________________________________________________________________ 
   * |                                                                                                 |
   * |          |'-.__                                                                                 |
   * |          / ' _/                                                                                 |
   * |          ****'          /\      | |                      | (_)                                  |
   * |         /    )         /  \   __| | __ _ _ __ ___        | |_ _ __ ___   ___ _ __   ___ ____    |
   * |        /  \ /         / /\ \ / _' |/ _' | '_ ' _ \   _   | | | '_ ' _ \ / _ \ '_ \ / _ \_  /    |
   * |    \ /'   \\\         / ____ \ (_| | (_| | | | | | | | |__| | | | | | | |  __/ | | |  __// /     |     
   * |    '\    /_\\\       /_/    \_\__,_|\__,_|_| |_| |_|  \____/|_|_| |_| |_|\___|_| |_|\___/___|    |          
   * |      '~~~~~''~'                                                                                 |
   * |                             Github: https://github.com/Adam-Jimenez                             |
   * |                          LinkedIn: https://www.linkedin.com/in/adamjim/                         |
   * |                                                                                                 |
   * |                                                                                                 |
   * |_________________________________________________________________________________________________|
   *
   *  Created at: `strftime("%B %d, %Y")`
   *
  */
  #include <iostream>
  #include <sstream>
  #include <cstdio>
  #include <cmath>
  #include <cstring>
  #include <cctype>
  #include <string>
  #include <vector>
  #include <list>
  #include <set>
  #include <map>
  #include <unordered_map>
  #include <unordered_set>
  #include <queue>
  #include <stack>
  #include <algorithm>
  #include <functional>

  using namespace std;

  struct pair_hash{template <class T1, class T2> size_t operator()(pair<T1,T2> const &pair) const {
    return hash<T1>()(pair.first) ^ hash<T2>()(pair.second);
  }};

  const int INF = 1 << 29;
  const double PI=acos(-1);
  const double EPS = 1e-9;

  typedef long long ll;

  #define PII std::pair<int,int>

  template<typename T> T max(vector<T> v) { return *max_element(v.begin(), v.end()); }
  template<typename T> T min(vector<T> v) { return *min_element(v.begin(), v.end()); }
  template <typename T> T modpow(T base, T exp, T modulus) { 
    base %= modulus; T result = 1;
    while (exp > 0) {
      if (exp & 1) result = (result * base) % modulus;
      base = (base * base) % modulus; exp >>= 1;
    } return result;
  }
  inline bool f_eq(double a, double b) { return fabs(a-b) < EPS; }
  inline int ctoi(char c) { return c-'0'; }
  inline char itoc(int i) { return '0'+i; }
  long long gcd(long long a, long long b){return(b?__gcd(a,b):a);}
  long long lcm(long long a, long long b){return(a*(b/gcd(a,b)));}
  vector<string> split(string s, string delim){
      std::vector<string> v; string acc;
      for (char c: s) if (delim.find(c)!=string::npos) { v.push_back(acc); acc = ""; } else { acc += c; }
      v.push_back(acc); return v;
  }

  void solve()
  {

  }

  int main(int argc, const char *argv[])
  {
    std::ios::sync_with_stdio(false);
    ${0:TARGET}
  }
